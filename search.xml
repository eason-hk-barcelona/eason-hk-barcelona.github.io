<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>爱在黎明破晓前（Before Sunrise）</title>
      <link href="/2024/11/03/2024-11-3-%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/03/2024-11-3-%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="深入响应式系统"><a href="#深入响应式系统" class="headerlink" title="深入响应式系统"></a>深入响应式系统</h1><blockquote><p>宇宙免责声明：本文不是知识梳理，旨在抛砖引玉！！！</p></blockquote><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote><p>想象你是一个高级小区的业主，你的公寓门口配备了诸多门卫，以监控和干预所有进出公寓的行为</p></blockquote><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>一个 <code>Proxy</code> 对象（门卫）包装另一个对象并拦截诸如读取&#x2F;写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><ul><li><code>target</code> —— 是要包装的对象（公寓），可以是任何东西，包括函数。</li><li><code>handler</code> —— 带有<strong>捕捉器</strong>（即拦截操作的方法）的对象。比如 <code>get</code> 捕捉器用于读取 <code>target</code> 的属性，<code>set</code> 捕捉器用于写入 <code>target</code> 的属性，等等。</li></ul><h3 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h3><blockquote><p>proxy到底用来拦截什么？</p></blockquote><p>对于对象的大多数操作，JavaScript 规范中有一个所谓的“内部方法”，它描述了最底层的工作方式。例如 <code>[[Get]]</code>，用于读取属性的内部方法，<code>[[Set]]</code>，用于写入属性的内部方法。</p><p>对每一个内部方法，都有一个对应的Proxy handler去拦截这些方法的调用：<a href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">proxy规范</a></p><h4 id="一个简单的举例"><a href="#一个简单的举例" class="headerlink" title="一个简单的举例"></a>一个简单的举例</h4><p><img src="D:\Blog\source\img\17306199948285.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="keyword">const</span> apartment = &#123;</span><br><span class="line">    <span class="attr">temperature</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">residents</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 门卫</span></span><br><span class="line"><span class="keyword">const</span> apartmentProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(apartment, &#123;</span><br><span class="line">    <span class="comment">// handler_1</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">        <span class="comment">//log</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`有人想要查看<span class="subst">$&#123;prop&#125;</span>的信息`</span>);</span><br><span class="line">        <span class="keyword">return</span> target[prop];</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// handler_2</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">        <span class="comment">//log</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`有人想要修改<span class="subst">$&#123;prop&#125;</span>为<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">// 例如：只允许温度在18-30度之间</span></span><br><span class="line">        <span class="keyword">if</span> (prop === <span class="string">&#x27;temperature&#x27;</span> &amp;&amp; (value &lt; <span class="number">18</span> || value &gt; <span class="number">30</span>)) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;温度设置被拒绝：超出合理范围！&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target[prop] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p><code>Reflect</code> 是一个内建对象，前面所讲过的内部方法，例如 <code>[[Get]]</code> 和 <code>[[Set]]</code> 等，都只是规范性的，不能直接调用。<code>Reflect</code> 对象使调用这些内部方法成为了可能。对于每个可被 <code>Proxy</code> 捕获的内部方法，在 <code>Reflect</code> 中都有一个对应的方法，其名称和参数与 <code>Proxy</code> 捕捉器相同。</p><p><img src="D:\Blog\source\img\17306199947781.png" alt="img"></p><p>因此，我们可以通过 <code>Reflect</code> 将操作转发给原始对象。</p><h3 id="Reflect有什么优势？"><a href="#Reflect有什么优势？" class="headerlink" title="Reflect有什么优势？"></a>Reflect有什么优势？</h3><blockquote><p>你可能会问，既然我们总是要调用内部方法的，为什么还要用Reflect在proxy中调这些方法呢？</p><p>这里以Reflect.get为例阐述其在处理继承关系的优势</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> owner = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;Eason&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ownerProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(owner, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[prop]; <span class="comment">// (*) target = owner</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> guest = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: ownerProxy,</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;Guest&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望输出：Guest</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(guest.<span class="property">name</span>); <span class="comment">// 实际输出：Eason</span></span><br></pre></td></tr></table></figure><p>我们希望读取 <code>guest.name</code>返回 <code>Guest</code>，而不是 <code>Eason</code>，问题出在哪里呢？</p><p>分析：</p><ol><li>读取 <code>guest.name</code>，由于 <code>guest</code>对象没有name属性，搜索转到其原型 <code>ownerProxy</code></li><li>从代理读取name时，get handler触发，从owner对象返回 <code>owner[prop]</code></li><li>此时的prop是一个getter，它将在 <code>this=target</code>上下文中返回 <code>_name</code></li><li>如何把上下文传递给 getter？这本质其实是一个this指向问题，对一般的<strong>数据属性</strong>我们可以用call&#x2F;apply&#x2F;bind处理，但getter是访问器属性，它不能“被调用”，只能被访问。</li></ol><p>解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> owner = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;Eason&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ownerProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(owner, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> guest = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: ownerProxy,</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&quot;Guest&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(guest.<span class="property">name</span>); <span class="comment">// 实际输出：Guest</span></span><br></pre></td></tr></table></figure><p>我们需要用到get handler的第三个参数 <code>receiver</code>，它保留了对正确this(Guest)的引用，通过 <code>Reflect.get</code>传递给getter</p><h2 id="Proxy局限性"><a href="#Proxy局限性" class="headerlink" title="Proxy局限性"></a>Proxy局限性</h2><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><blockquote><p>为突出逻辑，以下部分代码在源码的基础上有适当改动</p></blockquote><h2 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h2><p>在初始化阶段，Vue2会对配置对象中的不同属性做相关处理</p><ul><li><code>data</code>和 <code>props</code>中的每个属性变成响应式属性，每个属性内部持有一个Dep依赖收集器</li><li>对 <code>computed</code>计算属性，内部创建computed watcher，每个computed watcher持有一个Dep依赖收集器</li><li>对 <code>watch</code>，内部创建user watcher，即用户自定义的一些watch，<code>data</code> or <code>computed</code>中的属性Dep会存储与自己相关的watcher</li></ul><p><img src="D:\Blog\source\img\17306199947782.png" alt="img"></p><h3 id="侦测数据变化"><a href="#侦测数据变化" class="headerlink" title="侦测数据变化"></a>侦测数据变化</h3><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>在Vue2中，利用 <code>Observer</code>类和 <code>Object.defineProperty</code>，通过劫持对象属性，实现侦测数据变化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span></span><br><span class="line">  <span class="attr">vmCount</span>: <span class="built_in">number</span> <span class="comment">// 根$data的Vue实例数量</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> value: <span class="built_in">any</span>, <span class="keyword">public</span> shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vmCount</span> = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 新增一个__ob__属性，标记此 value 已经变为响应式了</span></span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="comment">// type 是 Array 时</span></span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">          <span class="comment">// 如果浏览器支持__proto__，直接设置原型链</span></span><br><span class="line">          ;(value <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">__proto__</span> = arrayMethods</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不支持__proto__时，逐个复制方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = arrayKeys.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> key = arrayKeys[i]</span><br><span class="line">          <span class="title function_">def</span>(value, key, arrayMethods[key])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// type 是 Object 时，遍历其所有属性添加 get/set</span></span><br><span class="line">      <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(value)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i]</span><br><span class="line">        <span class="title function_">defineReactive</span>(value, key, <span class="variable constant_">NO_INITIAL_VALUE</span>, <span class="literal">undefined</span>, shallow, mock)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 为Array的每一个元素创建 Observer</span></span><br><span class="line">  <span class="title function_">observeArray</span>(<span class="params">value: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(value[i], <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defineReacitve"><a href="#defineReacitve" class="headerlink" title="defineReacitve"></a>defineReacitve</h4><p>对象的属性定义响应式，Vue2使用 <code>defineReactive</code>将一个对象转化成可观测对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  key: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  val?: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  shallow?: <span class="built_in">boolean</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数处理，只传了obj和key，那么val = obj[key]</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj里嵌套对象，递归添加响应式，进行深度侦测 </span></span><br><span class="line">  <span class="keyword">let</span> childOb = shallow ? val &amp;&amp; val.<span class="property">__ob__</span> : <span class="title function_">observe</span>(val, <span class="literal">false</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 收集 Watcher</span></span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">          <span class="comment">// value 是 Array 时特殊处理</span></span><br><span class="line">          <span class="title function_">dependArray</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">hasChanged</span>(value, newVal)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// obj里嵌套对象，递归添加响应式，进行深度侦测 </span></span><br><span class="line">      childOb = shallow ? newVal &amp;&amp; newVal.<span class="property">__ob__</span> : <span class="title function_">observe</span>(newVal, <span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//通知 Wathcer 进行视图更新</span></span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>通过以上方法仅只能观测Object数据的取值getter和修改更新已有数据setter，为解决这一点，Vue2增加了两个全局API，<code>Vue.set(vm.$set)</code> 和 <code>Vue.delete(vm.$delete)</code></li><li><code>Object.defineProperty</code> 仅可以检测数组的下标变化（即通过下标获取某个元素和修改元素值），但无法检测数组长度变化，因此在 <a href="https://github.com/vuejs/vue/blob/main/src/core/observer/array.ts">array.ts</a> 对 <code>push</code>、<code>unshift</code>、<code>splice</code>进行了特殊处理，也是为什么Observer需要特判</li><li><code>Object.defineProperty</code>需要遍历对象的每个属性，假如属性值也是对象，则需要递归地遍历，性能较低</li></ol><h3 id="依赖收集与更新"><a href="#依赖收集与更新" class="headerlink" title="依赖收集与更新"></a>依赖收集与更新</h3><blockquote><p>数据变的可观测后，我们可以知道数据什么时候发生了变化，那么现在的问题就是当某个数据变化后，我们该通知哪部分视图进行更新？</p></blockquote><h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><blockquote><p>对象的每个属性都有一个Dep依赖管理器，其串联了属性和sub(或effect)</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dep存储Watcher</span></span><br><span class="line"><span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="attr">subs</span>: [<span class="title class_">Watcher1</span>, <span class="title class_">Watcher2</span>, ...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watcher存储Dep</span></span><br><span class="line"><span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="attr">deps</span>: [<span class="title class_">Dep1</span>, <span class="title class_">Dep2</span>, ...],</span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">Set</span>(<span class="number">1</span>, <span class="number">2</span>, ...)  <span class="comment">// 用于去重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个属性被访问，其通过depend收集访问它的watcher，当其数据变化，通过notify遍历更新所有依赖它的watcher</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> target?: <span class="title class_">DepTarget</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">DepTarget</span> | <span class="literal">null</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub: DepTarget</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略remove</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//收集依赖</span></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="comment">//dep.addSub(target)</span></span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//派发更新</span></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 浅拷贝</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">s</span> =&gt;</span> s) <span class="keyword">as</span> <span class="title class_">DepTarget</span>[]</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 遍历 Watcher update</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub = subs[i]</span><br><span class="line">      sub.<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><h3 id="更新？"><a href="#更新？" class="headerlink" title="更新？"></a>更新？</h3><ol><li>Vue2中，响应式系统主要是为对象设计的，假如我们需要处理一个基本类型（Number，String…）的数据，需要将其包装在对象中。因此Vue3在reactive的基础上推出了ref，它提供了一种更自然的方式来直接处理任意类型。</li><li>使用 <code>Proxy</code>直接代理对象，直接监听整个对象<ol><li>不需要重写array方法</li><li>可监听属性的新增和删除（不再使用set和delete）</li></ol></li><li>相较于使用数组进行watcher的存储，采用 <code>WeakMap&lt;target, Map&lt;key, Set&lt;effect&gt;&gt;&gt;</code>结构，可自动垃圾回收<ol><li><img src="D:\Blog\source\img\17306199947783.png" alt="img"></li></ol></li></ol><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h3><p><img src="D:\Blog\source\img\17306199947784.png" alt="img"></p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>ref函数本身很简单，就是直接调用 <code>createRef</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createRef`中对传入的rawValue进行判断，假如已经是响应式，直接返回，不是则作为参数传入`RefImpl</span><br><span class="line">function createRef(rawValue: unknown, shallow: boolean) &#123;</span><br><span class="line">  if (isRef(rawValue)) &#123;</span><br><span class="line">    return rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  return new RefImpl(rawValue, shallow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RefImpl"><a href="#RefImpl" class="headerlink" title="RefImpl"></a>RefImpl</h4><p><code>RefImpl</code>中维护一个 <code>_value</code>，其值就是平时我们调用.value获取ref的值；维护一个 <code>_rawValue</code>，用于和set的 <code>newValue</code>比较，判断是否触发 <code>trigger</code>进行响应式更新；维护一个Dep，记录依赖该属性的Subscriber（在Vue2中叫Watcher）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T = <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="attr">_value</span>: T</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_rawValue</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REF</span>] = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> [<span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>]: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, isShallow: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = isShallow ? value : <span class="title function_">toRaw</span>(value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">    <span class="variable language_">this</span>[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>] = isShallow</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span>.<span class="title function_">track</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">_rawValue</span></span><br><span class="line">    <span class="keyword">const</span> useDirectValue =</span><br><span class="line">      <span class="variable language_">this</span>[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>] ||</span><br><span class="line">      <span class="title function_">isShallow</span>(newValue) ||</span><br><span class="line">   </span><br><span class="line">    newValue = useDirectValue ? newValue : <span class="title function_">toRaw</span>(newValue)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newValue, oldValue)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newValue</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newValue : <span class="title function_">toReactive</span>(newValue)</span><br><span class="line">    </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dep</span>.<span class="title function_">trigger</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当newValue是Proxy对象，调用 <code>toRaw</code>将其转成originalObj</li><li>_value调用 <code>toReactive</code>获得，由下面代码可看出其作用即根据value的type进行区别处理，若是Object，交给reactive处理，基础类型则直接返回，即处理对象之前加了一条分支判断</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toReactive = &lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>&gt;(<span class="attr">value</span>: T): <span class="function"><span class="params">T</span> =&gt;</span></span><br><span class="line">  <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value</span><br></pre></td></tr></table></figure><h4 id="createReactiveObject"><a href="#createReactiveObject" class="headerlink" title="createReactiveObject"></a>createReactiveObject</h4><p>到这其实就进入在Vue3中使用reactive声明变量的流程（即 <code>const var = reactive(&#123;count: 1&#125;)</code>），函数reactive在做完简单的可读性处理后直接调用 <code>createReactiveObject</code>，其核心逻辑就是为target创建一个Proxy对象，并根据 <code>targetType</code>传入不同的 <code>handler</code></p><p><strong>targetType</strong>：</p><ul><li>COMMON：Object、Array</li><li>COLLECTION：Map、Set、WeakMap、WeakSet</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: Target,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params">  proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt;,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//target本身是Proxy（与源码有出入，以逻辑为主）</span></span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//target已经存在Proxy</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//类型处理</span></span><br><span class="line">  <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers,</span><br><span class="line">  )</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖收集与更新-1"><a href="#依赖收集与更新-1" class="headerlink" title="依赖收集与更新"></a>依赖收集与更新</h3><p>和Vue2一样，Vue3同样通过track进行依赖收集，trigger进行派发更新，只不过二者是在handler执行</p><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>Vue2通过数组实现属性和watcher之间之间的双向依赖收集，而Vue3采用链表实现双向链接，进一步降低了依赖清理的时间复杂度（O(n)–&gt;O(1)），提高了依赖管理的性能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Link</span> &#123;</span><br><span class="line">  <span class="attr">sub</span>: <span class="title class_">Effect</span>,    <span class="comment">// 指向effect</span></span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span>,       <span class="comment">// 指向dep</span></span><br><span class="line">  <span class="attr">nextDep</span>: <span class="title class_">Link</span>,  <span class="comment">// effect的下一个依赖</span></span><br><span class="line">  <span class="attr">prevDep</span>: <span class="title class_">Link</span>,  <span class="comment">// effect的上一个依赖</span></span><br><span class="line">  <span class="attr">nextSub</span>: <span class="title class_">Link</span>,  <span class="comment">// dep的下一个订阅者</span></span><br><span class="line">  <span class="attr">prevSub</span>: <span class="title class_">Link</span>   <span class="comment">// dep的上一个订阅者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h4><p>我们以下涉及多层 effect 嵌套例子为例，走一遍依赖收集与更新的流程：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> triple = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> double.<span class="property">value</span> * <span class="number">1.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Triple value is: <span class="subst">$&#123;triple.value&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>effect是subscriber接口的具体实现，其中包含了批处理机制、依赖清理等逻辑，其核心 <code>ReactiveEffect</code>的主要逻辑为 <code>run</code>方法，其余与生命周期，自定义调度等相关的属性和方法这里不做进一步阐述</p><ol><li>首先，watchEffect创建了一个 <code>ReactiveEffect</code>，double和triple同理，当执行watchEffect时，调用其 <code>run</code>方法:</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">run</span>(): T &#123;</span><br><span class="line">  <span class="comment">//清理之前的依赖</span></span><br><span class="line">  <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//准备新的依赖</span></span><br><span class="line">  <span class="title function_">prepareDeps</span>(<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存 watchEffect 上下文</span></span><br><span class="line">  <span class="keyword">const</span> prevEffect = activeSub  <span class="comment">//此时是null</span></span><br><span class="line">  <span class="keyword">const</span> prevShouldTrack = shouldTrack</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置 watchEffect 为当前 active 的 effect</span></span><br><span class="line">  activeSub = <span class="variable language_">this</span></span><br><span class="line">  shouldTrack = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()  <span class="comment">//console.log(`Triple value is: $&#123;triple.value&#125;`)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开始嵌套...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//清理 watchEffect 的依赖</span></span><br><span class="line">    <span class="title function_">cleanupDeps</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">//现场恢复</span></span><br><span class="line">    activeSub = prevEffect</span><br><span class="line">    shouldTrack = prevShouldTrack</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Vue3使用全局变量来跟踪当前正在执行的effect：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="attr">activeSub</span>: <span class="title class_">Subscriber</span> | <span class="literal">undefined</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> shouldTrack = <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>由run代码可以看出，当一个effect开始执行时，会将自己设置为activeSub（当前活跃的effect）</li><li>每次run的时候都需要清理之前的依赖，因为每次所需的依赖可能有区别</li><li>当访问triple.value时，其还未计算过值，触发triple的effect运行，double同理，给出effect嵌套执行依赖和执行栈变化：<ul><li>count -&gt; double -&gt; triple -&gt; watchEffect</li><li>执行栈变化：<ol><li>初始：<code>activeSub: null</code>，<code>shouldTrack: true</code></li><li>watchEffect：<code>activeSub: watchEffectInstance</code>，<code>shouldTrack: true</code></li><li>triple：<code>activeSub: tripleEffectInstance</code>，<code>shouldTrack: true</code></li><li>double：<code>activeSub: doubleEffectInstance</code>，<code>shouldTrack: true</code></li></ol></li></ul></li><li>通过保存和恢复上下文（activeSub &amp; shouldTrack），可以很好的处理嵌套effect</li></ul><ol><li>对于每一个正在执行的effect，由于将自己暴露为全局变量activeSub，其依赖可以在track的时候轻松获取</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dep.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">unknown</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeSub) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()))</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//用于依赖清理</span></span><br><span class="line">      dep.<span class="property">map</span> = depsMap</span><br><span class="line">      dep.<span class="property">key</span> = key</span><br><span class="line">    &#125;</span><br><span class="line">    dep.<span class="title function_">track</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dep.ts</span></span><br><span class="line"><span class="comment">// dep.track()</span></span><br><span class="line"><span class="title function_">track</span>(): <span class="title class_">Link</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!activeSub || !shouldTrack || activeSub === <span class="variable language_">this</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> link = <span class="variable language_">this</span>.<span class="property">activeLink</span></span><br><span class="line">  <span class="keyword">if</span> (link === <span class="literal">undefined</span> || link.<span class="property">sub</span> !== activeSub) &#123;</span><br><span class="line">    link = <span class="variable language_">this</span>.<span class="property">activeLink</span> = <span class="keyword">new</span> <span class="title class_">Link</span>(activeSub, <span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// effect收集依赖</span></span><br><span class="line">    <span class="keyword">if</span> (!activeSub.<span class="property">deps</span>) &#123;</span><br><span class="line">      activeSub.<span class="property">deps</span> = activeSub.<span class="property">depsTail</span> = link</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      link.<span class="property">prevDep</span> = activeSub.<span class="property">depsTail</span></span><br><span class="line">      activeSub.<span class="property">depsTail</span>!.<span class="property">nextDep</span> = link</span><br><span class="line">      activeSub.<span class="property">depsTail</span> = link</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dep收集依赖——link.dep.subs.nextSub = link</span></span><br><span class="line">    <span class="title function_">addSub</span>(link)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (link.<span class="property">version</span> === -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//重用已存在的Link对象，减少内存分配和gc</span></span><br><span class="line">    link.<span class="property">version</span> = <span class="variable language_">this</span>.<span class="property">version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重排，依赖列表按最新访问顺序</span></span><br><span class="line">    <span class="keyword">if</span> (link.<span class="property">nextDep</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> next = link.<span class="property">nextDep</span></span><br><span class="line">      next.<span class="property">prevDep</span> = link.<span class="property">prevDep</span></span><br><span class="line">      <span class="keyword">if</span> (link.<span class="property">prevDep</span>) &#123;</span><br><span class="line">        link.<span class="property">prevDep</span>.<span class="property">nextDep</span> = next</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      link.<span class="property">prevDep</span> = activeSub.<span class="property">depsTail</span></span><br><span class="line">      link.<span class="property">nextDep</span> = <span class="literal">undefined</span></span><br><span class="line">      activeSub.<span class="property">depsTail</span>!.<span class="property">nextDep</span> = link</span><br><span class="line">      activeSub.<span class="property">depsTail</span> = link</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (activeSub.<span class="property">deps</span> === link) &#123;</span><br><span class="line">        activeSub.<span class="property">deps</span> = next</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> link</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>假设此时更新了 <code>count.value = 1</code>，此时触发trigger</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dep.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  key?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">startBatch</span>()  <span class="comment">// 开始批量更新</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取依赖该属性的effect</span></span><br><span class="line">  <span class="keyword">const</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">    dep.<span class="title function_">trigger</span>()  <span class="comment">// 触发更新</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">endBatch</span>()   <span class="comment">// 结束批量更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dep.ts</span></span><br><span class="line"><span class="title function_">trigger</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// 版本管理...</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">notify</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">notify</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="title function_">startBatch</span>()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> link = <span class="variable language_">this</span>.<span class="property">subs</span>; link; link = link.<span class="property">prevSub</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (link.<span class="property">sub</span>.<span class="title function_">notify</span>()) &#123;</span><br><span class="line">        <span class="comment">// 对computed优先调用notify，而不是在computed内调用notify，减少递归栈</span></span><br><span class="line">        ;(link.<span class="property">sub</span> <span class="keyword">as</span> <span class="title class_">ComputedRefImpl</span>).<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title function_">endBatch</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里对dep的subs进行逆序遍历，即watchEffect-&gt;triple-&gt;double，主要为了配合<strong>批处理</strong>机制（batch processing）：<ul><li>假如我们正向遍历，更新double的时候会触发triple更新，triple又会触发watchEffect更新…如此往复需要（On^2）复杂度才可更新完嵌套执行的effect</li><li>而逆序遍历，先触发watchEffect更新，维护一个链表，采用头插法不断往其中加入effect，最后只需要On从头遍历一遍该链表即可完成嵌套effect的更新，且保证更新顺序按照subs原始的存储顺序更新</li></ul></li><li>由以上代码可得出computed会被优先处理，再处理普通effect</li><li>至此，此时double被更新成2，triple更新成3，打印Triple value is: 3</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Vue2源码：<a href="https://github.com/vuejs/vue">https://github.com/vuejs/vue</a></p><p>Vue3源码：<a href="https://github.com/vuejs/core">https://github.com/vuejs/core</a></p><p>Vue官方文档：<a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth#how-reactivity-works-in-vue">https://cn.vuejs.org/guide/extras/reactivity-in-depth#how-reactivity-works-in-vue</a></p><p>特别鸣谢web某小动物：<a href="https://www.cheems.life/blog/65">https://www.cheems.life/blog/65</a></p>]]></content>
      
      
      <categories>
          
          <category> 影评 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>繁花</title>
      <link href="/2024/07/08/2024-1-19-%E7%B9%81%E8%8A%B1/"/>
      <url>/2024/07/08/2024-1-19-%E7%B9%81%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="繁花"><a href="#繁花" class="headerlink" title="繁花"></a>繁花</h1><pre><code>一开始是奔着精彩商战，各方博弈去看的，没想到带给我的却是一层又一层的惊喜和震撼。不管是剧情内容，拍摄手法，镜头语言，角色刻画，演员张力，bgm选曲，我认为繁花都做的极佳，也让我对八九十年代的上海有了更深入的了解。八九十年代，迎着改革开放的春风，股票，外贸是时代的风口，人们穿行在上海滩的滚滚红尘中，都希望从中分一杯羹，扶摇而上。散户，舰队，麒麟会，再到后面南国投，每一次的新玩法，都象征着市场的迭代升级，也一次次刺激着经济发展。和外资合作，敢拼，敢做，敢摸着石头过河，上的了像至真园般的饭店谈笑风生，下的了深圳一个小县城的工厂里放下身段。饭店吃饭，吃的是合作；一只龙虾，就是一次机会；饭店里的食客，不是在应酬，就是在求人。一切的一切，像极了盖茨比中西方”咆哮的二十年代“。30年前如此，30年后又有什么变化呢？十几二十年前的房地产，当下的互联网，电商，自媒体，AI...一个又一个时代风口接踵而至。或许你机智聪慧，有创业头脑，又有贵人身旁，成功如宝总；或许你顽强不屈，为争一口气，拼搏如汪小姐；或许你运筹帷幄，有勇有谋，闯荡如李李；或许你后来独立自强，有主张、搞得定、摆得平，输得起如玲子；或许你不过是和人一起合作随大流，像蔡司令，小宁波，菱红，葛老师赚了点小钱，但收获珍贵友情；或许你爱慕虚荣，但拎得清谁是你真正的朋友，有一群至交；或许你爱情事业都不顺利，但精神富足，平平淡淡.....</code></pre><p><img src="/../img/1.jpg" alt="1"></p><pre><code>繁花落尽，冬去春来，没有人永远年轻，没有人永远得势，有多少歌舞升平，就有多少人走茶凉，青山依旧在，几度夕阳红...尽管当初的人已不再，但在无数寻常巷陌，市井邻里，在无数机遇，智慧，人情，敬佩，恐惧，喜悲，嫉妒，生存的碰撞中，绚烂的经典会留下，新的故事会上演。有时候过去的不经意，却是当时的转折点，而当初你所认为的一切，不过是一片羽毛。或许正如剧中所说：”人总要赶一头，要么走要么留，唯独不好后悔，后悔没药可救的“。站在每一个抉择的十字路口，但凡做出了选择，那便一步步，一天天，只管全力以赴，剩下的交给时间。</code></pre><p><img src="/../img/2.jpg" alt="2"></p><pre><code>再回首，恍然如梦；再回首，我心依旧……希望我们在人生的风雨中，永远做自己的码头！</code></pre><p>剧中选曲：</p><p>《再回首》、《偷心》、《不再犹豫》、《光辉岁月》、《喜欢你》、《执迷不悔》、《突如其来的爱情》、《安妮》、《你是我胸口永远的痛》、《新鸳鸯蝴蝶梦》</p>]]></content>
      
      
      <categories>
          
          <category> 影评 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爱在黎明破晓前（Before Sunrise）</title>
      <link href="/2024/07/07/2024-7-7-%E7%88%B1%E5%9C%A8%E9%BB%8E%E6%98%8E%E7%A0%B4%E6%99%93%E5%89%8D%EF%BC%88Before%20Sunrise%EF%BC%89/"/>
      <url>/2024/07/07/2024-7-7-%E7%88%B1%E5%9C%A8%E9%BB%8E%E6%98%8E%E7%A0%B4%E6%99%93%E5%89%8D%EF%BC%88Before%20Sunrise%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="爱在黎明破晓前（Before-Sunrise）"><a href="#爱在黎明破晓前（Before-Sunrise）" class="headerlink" title="爱在黎明破晓前（Before Sunrise）"></a>爱在黎明破晓前（Before Sunrise）</h1><pre><code>偶然一次逛b站看到的剪辑，翻看评论发现叫爱在三部曲，这是第一部，诞生于1995年，导演是理查德·林克莱特，据说是根据自己在费城的经历拍出的艺术。影片基本就围绕男女主Jesse and Seline进行，讲述了二人彼此一见钟情，并crazy般的在维也纳度过了afternoon，midnight，sunrise的美丽故事。对于我来说，不得不佩服 Jesse 的勇敢，敢邀请 Seline 打破原计划而和他一起hang out，或许很多人会认为这是因为男主的帅气外表，但我更愿意相信是其幽默健谈、勇敢不羁的人格魅力打动了Seline。这部影片的拍摄成本非常低，不仅是相较于2024年来说，对比1995年的其它电影亦是如此，但这种简单，纯粹的拍摄手法却更能聚焦观众的注意在二人天马行空的对话中，从小时候的经历到彼此的人格（little boy versus old woman）；从对待手相奶奶的不同态度到彼此的ex-boy/girl friend；从在bus上的的quick talk到唱片店无处安放的情愫；从街边的促膝长谈到饭店幼稚的ring-ring calling；从贵格会教徒的奇葩结婚仪式到因milkshake谱写的一首短诗；从being rational adults 到 don’t be so complicated……</code></pre><p><img src="/../img/Untitled.png" alt="1"></p><pre><code>导演将人最美丽，最有生命力，最富有激情，最无畏，最韶华的恋爱展现的淋漓精致，你一眼我一眼的偷瞄，你抬头我低头的错落，你注视我扭头的羞怯……考虑什么异地，思考什么未来，只有眼前，only当下，before sunrise。</code></pre><p><img src="/../img/Untitled1.png" alt="2"></p><p><img src="/../img/Untitled2.png" alt="3"></p><pre><code>如往常一样，看完电影后我去b站搜了一下影评，有一个思路觉得很有道理：从列车上开始对彼此感兴趣，到摩天轮上”初吻“后“正式”在一起，再到由看手相老奶奶彼此都发现对方身上自己不那么喜欢的小缺点，再到Seline的一段独白：If there’s any kind of magic in this world,  it must be in the attempt of understanding someone, sharing something. I know, its almost impossible to succeed, but…who cares, really? The answer must be in the attempt. 二人开始接受彼此，由“喜欢”到“爱”，最后在草坪发生关系。导演将一段感情所需的经历浓缩在了一天，在黎明破晓前……</code></pre><p><img src="/../img/Untitled3.png" alt="4"></p><p><img src="/../img/Untitled4.png" alt="5"></p><pre><code>看电影的时候我就在想，before sunrise的受众可能会有较大的两极分化，理想或浪漫主义的人可能会觉得这是一部很棒的作品，而现实主义的人观影体验估计会比较boring，甚至根本没有毅力看完。好在我是一个摇摆不定的人，时而捡起地上的六便士，时而抬头看看天空中的月亮，所以尽管我一开始会有种撕裂感，但持续不久便是被人类最质朴，最真诚，最原始的表达方式所征服。最后，聊聊影片中与relationship无关的part：这部剧之所以被奉为经典，是其较为童话的邂逅，刚好相爱的两个人和他们唯美的爱情。这在高节奏，快发展的今天，或者说中国，是比较难复刻类似经历的，物以稀为贵，自然引发人们的美好遐想。再来是Seline独白里关于一个52岁的男人spent all of his life thinking about his career and his work, and it suddenly struck him that he had never really given anything of himself…我大概能懂他的感受，被物质捆绑，总是思考着如何更成功，但人类历史中一个很值得讨论的话题除了如何定义成功，还有如何定义自己 or 你想留什么给自己。我们暂且不谈年少的欢喜是否抵得过时间的白驹过隙，也不谈年轻气盛的春风得意是否会迈向岁月的柴米油盐。但总得体验一次吧，在酒吧，在机厅，在街边，在墓地，在黎明破晓前……</code></pre>]]></content>
      
      
      <categories>
          
          <category> 影评 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>像树一样生长</title>
      <link href="/2023/10/28/2023-10-28-%E5%83%8F%E6%A0%91%E4%B8%80%E6%A0%B7%E7%94%9F%E9%95%BF/"/>
      <url>/2023/10/28/2023-10-28-%E5%83%8F%E6%A0%91%E4%B8%80%E6%A0%B7%E7%94%9F%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="像树一样生长"><a href="#像树一样生长" class="headerlink" title="像树一样生长"></a>像树一样生长</h2><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><pre><code>作为一个文学水平巅峰停留在初高中的人来说能想要放下手中的ddl来写一些文字可谓极其稀有了，即便如此，我的确是有些东西和感悟要写，算是记录，算是回忆......</code></pre><h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><pre><code>大学，确实是有些魅力的，它令人着迷的点不仅是你摄入的知识（虽然你科的学生大多数时间都在干这个），还在你接触的人，看到的事。因为贵专业的缘故，其实我并没有接触到什么人，每天做的事也远不如进入大学前幻想的精彩，不过好在，我还是有了些思考。</code></pre><h4 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h4><pre><code>首先自然是讲讲学业，不知道其它学校或者华科其它专业的本科生教学水平怎么样，但是口口（华科计院）的教学实在不敢恭维，学的东西有用吗，肯定是有用的，但是内容确实也没有紧跟时代，再加上奇怪的时间安排，一门课学下来最后毕业了脑子里剩下的东西并不多。大多数人只是为了保研出国或者奖学金卷一个高分（羡慕会考试的，我想卷高分都不会），毕业了工作是不是计算机方向都不一定，就算是，大多数技能都是自学，即便你保研了，最终目的只要是就业，无非就是多读3-5年书，拿个研究生博士生的学历，让你在大学的 “温床” 多停留3-5年罢了。那如果留校执教呢，做科研确实是辛苦且伟大的工作，并且学术界不乏认真努力有成果的导师教授，但兼顾教学和科研的教师又有多少呢，不挂名不水论文的人又有多少呢，不接横向的导师又有多少呢。但是不可否认保研，出国还是有很大的吸引力，这也是大多数人（包括我）即便想也不敢置之学业不理的原因。当然了，这样的思考太过于主观，每个人有不同的生活方式和对学业的理解，想好自己怎么走最重要（谁来帮我想想我该怎么走 ）</code></pre><h4 id="世界观-amp-方法论"><a href="#世界观-amp-方法论" class="headerlink" title="世界观 &amp; 方法论"></a>世界观 &amp; 方法论</h4><pre><code>再来讲讲方法论和世界观。随着见识的积累，我对世界的构造和运作的感知确实是增长了，但如何看待这个世界，如何在这个社会生存，如何走接下去的人生，怎么把生命在有限的时间过的丰富精彩，我的方法论似乎还停留在初高中，你可以说是学生思维，也可以说是一种固化体系下的茫然感，简单来说，就是读的书太少（害）。都说成长就是慢慢能看清自己是什么样的人，我也发觉了自己身上的一些特点。有时我挺急的，例如代码一直debug不出来，调不通，我不是沉住气耐下性子思考发现问题，而是开始烦躁，心态炸裂，四处求救，甚至copy别人的，想着之后再研究问题出在哪。有时我不懂得拒绝，总是老好人的角色，或许在互联网上还犀利些，但实际这样活得有点儿累。有时我对待陌生人总是过于的热心，却因为懒放假在家都不愿意多去看望一下家里的老人（好在这个暑假开始多起来了），不珍惜和家庭相处的时光，初中的政治课教了我们 “家是心灵的港湾，是永远的避风港”，但作为家庭的一员，这种关系是相互的，我也得努力，多投入时间，去成为别人的港湾和避风港。有时候我会耗费自己的身体，牺牲一些健康，去达成后来回过头发现无关痛痒的事情，别等到年老了发现为此养了一身病，但我明白有时候当下很难放下（不然就太佛了），希望能减少，身体第一。有时我思考问题太过宏观，常常想生命的尽头，一辈子应该怎么安排，想要走的每一步都正确无瑕，结合上完美主义的坏毛病，直接导致了做事情进入状态慢，效率不高，过于谨慎，如履薄冰，但其实很多事情是得自己经历过才会真正成长，光靠想是想不出结果的，或者就是从书中汲取智慧（读书真的太重要，希望我能挤出时间看看书！）所以不如专注眼前。有的时候我明明懂得很多的这些道理，但就是执行力不够，意志不够坚定，浪费了太多时间。</code></pre><h4 id="本学期目前的总结"><a href="#本学期目前的总结" class="headerlink" title="本学期目前的总结"></a>本学期目前的总结</h4><pre><code>这学期经历了很多事，进了联创，了解了一下就业的学长学姐发展方向，每天被新人任务折磨的半死不活；进了鄂港联，认识了好多有意思的小伙伴，也参加了很多活动，最重要的还是锻炼了一些技能；开始采用新的应对考试模式（能不能破釜沉舟成功另说），开始翘一些课（真是不好但听不懂咋办）。前两天看了b站一个关于俞敏洪的视频，主题叫奔流，主要讲述了双减后的新东方和他的一些故事，颇有感触。三十余年的创业生涯，中国的经济如大河奔流，巨浪淘沙，无数时代的弄潮儿乘势而起，绚烂至极，又转瞬即逝，只有极少数的人能始终立于潮头。每个人都有想成功的梦，&quot;somebody has to win, so why not be me&quot;, 但有赢必有输，所以&quot;somebody has to lose, just do your best&quot;。不知从什么时候开始，我变的焦虑，犹豫，不安，功利，害怕失败，但这种感觉让我觉得漂浮在空中，不踏实，不沉稳，明明胜利是一时的，失败才是主旋律，正是那些百折不挠的经历锤炼了一个人，那些一次次的失败塑造了一个人。</code></pre><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><pre><code>人的一生很长，应该活的像跑马拉松。人的一生很短，希望能成长为更好的人。诸君共勉。2023.10.28 于华中科技大学启明楼联创团队</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活小感悟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典算法</title>
      <link href="/2023/05/31/2023-5-31-%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
      <url>/2023/05/31/2023-5-31-%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p>直接插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line"><span class="type">int</span> key = arr[i];<span class="comment">//存入当前元素 </span></span><br><span class="line"><span class="type">int</span> j = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; key&lt;arr[j])&#123;<span class="comment">//后面比前面小</span></span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>]=key;<span class="comment">//否则直接插在后面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>折半插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=L.length; ++i)&#123;</span><br><span class="line">L.r[<span class="number">0</span>] = L.r[i];<span class="comment">//L.r[i]暂存到L.r[0]</span></span><br><span class="line">low = <span class="number">1</span>; high = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">m = (high+low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(L.r[<span class="number">0</span>].key &lt; L.r[m].key) high = m<span class="number">-1</span>;<span class="comment">//低半区</span></span><br><span class="line"><span class="keyword">else</span> low = m+<span class="number">1</span>;<span class="comment">//高半区</span></span><br><span class="line">&#125;<span class="comment">//while</span></span><br><span class="line"><span class="keyword">for</span>(j = i<span class="number">-1</span>; j&gt;=high+<span class="number">1</span>; --j) L.r[j+<span class="number">1</span>] = L.r[j];<span class="comment">//high+1是插入位置</span></span><br><span class="line">L.r[high+<span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">&#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  减少比较次数，但没有减少移动次数</p></li><li><p>shell排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="type">int</span> gap, i, j;</span><br><span class="line"><span class="keyword">for</span>(gap = len&gt;&gt;<span class="number">1</span>; gap&gt;<span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(i=gap; i&lt;len; i++) &#123;</span><br><span class="line">arr[<span class="number">0</span>] = arr[i];<span class="comment">//暂存在arr[0]</span></span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;arr[<span class="number">0</span>]; j -= gap)</span><br><span class="line">            <span class="comment">//i-gap相当于该组上一个元素，j&lt;0则找到插入位置</span></span><br><span class="line">            arr[j+gap] = arr[j];</span><br><span class="line">            arr[j+gap] = arr[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><ul><li><p>冒泡排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">              flag = <span class="number">1</span>;</span><br><span class="line">              <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>快排</p><p>算法分析：时间复杂度O($nlogn$)， 其中选中心点是n，快排是$logn$，空间复杂度是O($logn$)，最坏是O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//分治思想</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)<span class="comment">//分段</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r);<span class="comment">//左右两段分别递归排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><ul><li><p>简单选择</p><p>算法思想：0–i-1对当前的i都先让min&#x3D;i，遍历i后面的所有值，若找到比i小的那么就更新min，并交换它们两个</p><p>分析：需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关，都是(n-1)n&#x2F;2次，需要移动记录的次数最多为3(n-1)次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="type">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span>(j = i+<span class="number">1</span>; j&lt;len; j++)<span class="comment">//走访未排序的元素</span></span><br><span class="line"><span class="keyword">if</span>(arr[j] &lt; arr[min]) min = j;</span><br><span class="line"><span class="built_in">swap</span>(arr[j], arr[min]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>堆排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以大根堆为例</span></span><br><span class="line"><span class="comment">//筛选</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> s, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">cur = arr[s];</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>*s; j&lt;m; j*=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j &lt; m &amp;&amp; arr[j]&lt;arr[j+<span class="number">1</span>]) ++j;<span class="comment">//if语句成立说明右子树比左子树大，j为较大的数</span></span><br><span class="line"><span class="keyword">if</span>(cur &gt;= arr[j])<span class="keyword">break</span>;<span class="comment">//已经根最大</span></span><br><span class="line">arr[s] = arr[j]; s = j; <span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line">arr[s] = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span> <span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span>(i = len/<span class="number">2</span>; i&gt;<span class="number">0</span>; --i)<span class="comment">//从最后一个非叶子结点开始</span></span><br><span class="line"><span class="built_in">HeapAdjust</span>(arr, i, len);</span><br><span class="line"><span class="keyword">for</span>(i = len; i&gt;<span class="number">1</span>; --i)&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">1</span>], arr[i]);<span class="comment">//最后一个叶子和根交换--&gt;放后面排序</span></span><br><span class="line"><span class="built_in">HeapAdjust</span>(arr, <span class="number">1</span>, len<span class="number">-1</span>);<span class="comment">//重新调整为大顶堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);<span class="comment">//左右两边递归排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;<span class="comment">//k为tmp数组中的索引</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<span class="comment">//两边都还没到头</span></span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid) tmp[k++] = q[i++];<span class="comment">//把剩余没比较的直接复制</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;=r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=l, j=<span class="number">0</span>; i&lt;=r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>实用于多个关键字情况 O(n)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>logistics</title>
      <link href="/2023/05/04/2023-5-4-logistics/"/>
      <url>/2023/05/04/2023-5-4-logistics/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-二元分类-x3D-x3D"><a href="#x3D-x3D-二元分类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;二元分类&#x3D;&#x3D;"></a>&#x3D;&#x3D;二元分类&#x3D;&#x3D;</h2><p>输出：标签1&#x2F;0</p><p>img在计算机中保存–&gt;三个矩阵（假设64*64，那么就有3 * 64 * 64个像素，变成特征向量，总维度，也就是矩阵的行为n&#x3D;3 * 64 * 64，如果有m组训练集，那么矩阵最终为m列，n行)</p><p><img src="/../img/%E4%B8%89%E4%B8%AA%E7%9F%A9%E9%98%B5.png" alt="三个矩阵"></p><h2 id="x3D-x3D-logistics回归-x3D-x3D"><a href="#x3D-x3D-logistics回归-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;logistics回归&#x3D;&#x3D;"></a>&#x3D;&#x3D;logistics回归&#x3D;&#x3D;</h2><p> y^ 表示 y 等于1的一种可能性或者是机会</p><p>w 表示逻辑回归的参数，这也是一个 n 维向量（因为 w 实际上是特征权重，维度与特征向量相同），参数里面还有 b，这是一个实数（表示偏差）</p><p>选择使用sigmoid函数原因：如果单纯线性，无法把y^值控制在0-1之间，故取sigmoid(z)</p><p>使得z很大，sigmoid(z)趋近1， z 变成一个绝对值很大的负数，sigmoid(z)趋近0</p><p><img src="/../img/sigmoid.png" alt="sigmoid"></p><h3 id="x3D-x3D-损失函数-x3D-x3D"><a href="#x3D-x3D-损失函数-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;损失函数&#x3D;&#x3D;"></a>&#x3D;&#x3D;损失函数&#x3D;&#x3D;</h3><p>$L(\hat{y},y) &#x3D; -y\log(\hat{y})-(1-y)\log(1-\hat{y})$    单次</p><p>成本（代价）函数：$J(w,b) &#x3D; \frac{1}{m}\sum_{i&#x3D;1}^{m}{(-y\log(\hat{y})-(1-y)\log(1-\hat{y}))}$ 也就是总代价，训练逻辑回归模型时候，我们需要找到合适的 w 和 b ，来让代价函数 J 的总代价降到最低</p><h2 id="x3D-x3D-梯度下降法-x3D-x3D"><a href="#x3D-x3D-梯度下降法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;梯度下降法&#x3D;&#x3D;"></a>&#x3D;&#x3D;梯度下降法&#x3D;&#x3D;</h2><p>J 为凸函数，没有局部最优，只有全局最优</p><p><img src="/../img/bowl.png" alt="bowl"></p><p><strong>朝最陡的下坡方向走一步，不断地迭代</strong></p><p>更新w，b  找到最合适的参数使得J &#x3D; Jmin<br><img src="/../img/repeat%20procedure.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Intro to deep learning</title>
      <link href="/2023/05/03/2023-5-3-intro%20to%20Deep%20learning/"/>
      <url>/2023/05/03/2023-5-3-intro%20to%20Deep%20learning/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-Deep-learning-x3D-x3D"><a href="#x3D-x3D-Deep-learning-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Deep learning&#x3D;&#x3D;"></a>&#x3D;&#x3D;Deep learning&#x3D;&#x3D;</h2><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>RELU 修正线性单元</p><p>独立神经元叠在一起 –&gt; 神经网络 –&gt; 只需要input x –&gt; output y（中间部分自己完成）</p><p><img src="/../img/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png" alt="image-20230503192115327"></p><p>supervised learning 监督学习       &#x3D;&#x3D;NN-&gt;neural net&#x3D;&#x3D;</p><ul><li>predict房价，ad投放   –&gt;  standard NN;</li><li>image  –&gt; CNN（卷积神经网络）</li><li>sequence data&#x3D;&#x3D;(eg. audio, language)&#x3D;&#x3D;  –&gt;  RNN （循环神经网络）</li><li>无人驾驶 –&gt; custom, hybrid(复杂)</li></ul><p> 结构化数据——对数据有很清晰的定义</p><p>非结构化数据——相对难解释给计算机</p><p><img src="/../img/%E7%BB%93%E6%9E%84&%E9%9D%9E%E7%BB%93%E6%9E%84.png" alt="image-20230503192013798"></p><p>要么神经网络规模大，要么数据量多</p><ul><li>data 早期</li><li>computation 当下</li><li>algorithms 创新算法为了加快计算速度，服务于规模更大的网络</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kadane算法-动态规划</title>
      <link href="/2023/04/28/2023-4-28-Kadane%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/04/28/2023-4-28-Kadane%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>Kadane算法-&gt;动态规划</p><p>最大连续子数组和：函数名称是MaxSubArray(L); 初始条件是线性表L已存在且非空，请找出一个具有最大和的连续子数组（子数组最少包含一个元素），操作结果是其最大和；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> curSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        curSum = curSum &gt; <span class="number">0</span> ? curSum + nums[i] : nums[i];</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; maxSum) &#123;</span><br><span class="line">            maxSum = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表类似</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快排 &amp; 归并</title>
      <link href="/2023/04/28/2023-4-28-%E5%BF%AB%E6%8E%92&amp;%E5%BD%92%E5%B9%B6/"/>
      <url>/2023/04/28/2023-4-28-%E5%BF%AB%E6%8E%92&amp;%E5%BD%92%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序-gt-平均O-nlogn-gt-不稳定"><a href="#快速排序-gt-平均O-nlogn-gt-不稳定" class="headerlink" title="快速排序-&gt;平均O(nlogn)-&gt;不稳定"></a>快速排序-&gt;平均O(nlogn)-&gt;不稳定</h3><h4 id="x3D-x3D-基本思想-x3D-x3D"><a href="#x3D-x3D-基本思想-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基本思想&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本思想&#x3D;&#x3D;</h4><h5 id="分治——以上是暴力做法-复杂度为O-n"><a href="#分治——以上是暴力做法-复杂度为O-n" class="headerlink" title="分治——以上是暴力做法 复杂度为O(n)"></a>分治——以上是暴力做法 复杂度为O(n)</h5><h5 id="优美解法如上"><a href="#优美解法如上" class="headerlink" title="优美解法如上"></a><img src="/../img/%E5%BF%AB%E6%8E%92%E6%9A%B4%E5%8A%9B.png" alt="快排暴力">优美解法如上</h5><h4 id="归并排序-gt-O-nlogn-gt-稳定"><a href="#归并排序-gt-O-nlogn-gt-稳定" class="headerlink" title="归并排序-&gt;O(nlogn)-&gt;稳定"></a>归并排序-&gt;O(nlogn)-&gt;稳定</h4><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;——难点在归并<br><img src="/../img/%E5%BD%92%E5%B9%B6.png" alt="归并"><br>关于复杂度：n除2^logn次得到1，也就是有logn层，每一层的复杂度为n，故总复杂度为nlogn</p><p><img src="/../img/%E5%BD%92%E5%B9%B6%E6%80%9D%E8%B7%AF.png" alt="归并思路"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端路径</title>
      <link href="/2023/04/28/2023-4-28-%E5%89%8D%E7%AB%AF%E8%B7%AF%E5%BE%84/"/>
      <url>/2023/04/28/2023-4-28-%E5%89%8D%E7%AB%AF%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前端路径"><a href="#前端路径" class="headerlink" title="前端路径"></a>前端路径</h1><h3 id="三大件"><a href="#三大件" class="headerlink" title="三大件"></a>三大件</h3><ul><li><h4 id="html5，css"><a href="#html5，css" class="headerlink" title="html5，css"></a>html5，css</h4><p>  这里推荐pink老师的前端入门教程：</p><p>  <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p><p>  可以先看到249集</p></li><li><h4 id="JS、BOM、DOM"><a href="#JS、BOM、DOM" class="headerlink" title="JS、BOM、DOM"></a>JS、BOM、DOM</h4><p>黑马程序员pink老师JavaScript基础语法：</p><p><a href="https://www.bilibili.com/video/BV1Sy4y1C7ha">https://www.bilibili.com/video/BV1Sy4y1C7ha</a></p><p>可以先看到286集</p></li></ul><h3 id="学习平台"><a href="#学习平台" class="headerlink" title="学习平台"></a>学习平台</h3><p>  W3School：<a href="https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></p><p>  MMDN：<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><p>  菜鸟教程：<a href="https://www.runoob.com/">https://www.runoob.com/</a></p><p>  当然还有：</p><p>  谷歌：<a href="https://www.google.com.hk/">https://www.google.com.hk/</a></p><h3 id="协同工具"><a href="#协同工具" class="headerlink" title="协同工具"></a>协同工具</h3><pre><code>git：https://www.liaoxuefeng.com/wiki/896043488029600github：https://github.com/</code></pre><p>  可以自己找一些项目做，主要多敲代码</p><p>  之后进阶可以学习react，vue框架</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/04/27/2023-4-27-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/04/27/2023-4-27-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p>yeah yeah yeah</p><p>要开始做博客了，大一上学期学姐就有推荐我尝试记录自己的成长历程</p><p>但无奈那时候太忙orz（懒是原罪）</p><p>这学期看了大物实验的blog觉得很帅</p><p>想自己尝试一下</p><p>希望先做个小demo出来</p><p>后续会不断完善滴！！！</p><pre><code>——Eason 28/04/23</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
